  ---
layout : 'default'
css    : 'guide'

title  : 'CSS'
type   : 'UI Guide'
---
<div class="segment">
  <div class="container">
    <h1 class="ui header">CSS Guide</h1>
  </div>
</div>
<div class="main container">
  
  <div class="peek">
    <div class="ui vertical pointing secondary menu">
      <a class="active item">Style Guide</a>
      <a class="item">Units</a>
      <a class="item">Techniques</a>
    </div>
  </div>

  
  <h2 class="ui dividing header">Style Guide</h2>
  
    <h4 class="ui header">Don't Hyphenate</h4>
    <p>All elements are designed to include their own namespace. As long as rules descend from their parent element there is no possibility of rule collision.</p>
    <p>Hyphenated class names often describe the intersection of separate concepts, and can be better written to represent each concept separately.</p>
    <div class="code" data-type="css">
    /* no no no */
    .ui.button-active-red {
      background-color: #FF0000;
      font-weight: bold;
      color: #FFFFFF;
    }

    /* better */
    .red.ui.button {
      background-color: #FF0000;
      color: #FFFFFF;
    }
    .active.ui.button {
      font-weight: bold;
    }
    </div>
    
    <h4 class="ui header">CSS Legibility</h4>
    <p>Adding extra formatting can help increase clarity in your code. We suggest separating css selectors on separate lines, adding a space after css properties with commas (like box-shadow) and placing a zero before any decimal value.</p>
   
    <div class="code" data-type="css">
    /* not so easy to read */
    .ui.widgets .widget, ui.widget, .ui.widget.type, ui.widgets .widget.type {
      color: #FFFFFF;
    }
    /* this should have spaces after commas and a zero before any decimal value */
    .ui.widget {
      color:rgba(0,0,0,.3);
    }
    
    /* easier to read */
    .ui.widgets .widget,
    .ui.widget,
    .ui.widgets .widget.type,
    .ui.widget.type {
      color: #FFFFFF;
    }
    /* properly formatted */
    .ui.widget {
      color: rgba(0, 0, 0, 0.3);
    }
    </div>
  
  
    <h4 class="ui header">Keep Things Ordered</h4>
    <p>Although css rule order may be considered a chore, grouping related rules together can help keep css code organized.</p>
    <p>An easy way to do this is to consider ordering rules from the outside in. First describing positioning rules, then border rules, margin, sizing, padding, font-size, line height and ending with vendor prefixed attributes.</p>
   
    <div class="code" data-type="css">
    /* not so easy to read */
    .ui.widgets .widget, ui.widget, .ui.widget.type, ui.widgets .widget.type {
      color: #FFFFFF;
    }
    /* more legible */
    .ui.widgets .widget,
    .ui.widget,
    .ui.widgets .widget.type,
    .ui.widget.type {
      color: #FFFFFF;
    }
      
    /* i have some extra time so lets group these rules */
    .ui.widget {
      position: relative;
      top: 0em;
      left: 0em;
      
      margin: 1em;
      border: 1px solid rgba(0, 0, 0, 0.1);
      width: 100px;
      height: 100px;
      padding: 1em;
      
      font-size: 1.2em;
      color: rgba(0, 0, 0, 0.8);
      line-height: 1.2em;
      
      -webkit-border-radius: 0.3em;
      -moz-border-radius: 0.3em;
      border-radius: 0.3em;
    }
    </div>
  
  <h4 class="ui header">No wrappers, no excess markup</h4>
  <p>UI elements should be designed to include the minimum footprint of an element. If extra styling is needed, consider using pseudo selectors :after and :before. This allows for the creation of two extra divs inside each div context which can almost always be enough to accomodate extra styling.</p>
  <p>If there is no other option than wrapping content in a containing HTML element, consider using a name that describes the content instead of the word wrapper or container.</p>
    <div class="code" data-type="css">
    /* not tops */
    .ui.message .wrapper .title,
    .ui.message .wrapper .description {
      
    }
    /* better */
    .ui.message .content .title,
    .ui.message .content .description {
      
    }
    </div>

    <h4 class="ui header">Margins</h4>
    <p>Adding default margins to your content allow for it to have vertical rhythm in a page, but be careful about forcing margin in all circumstances. Here's a useful way to make sure content inside container elements doesn't receieve unnecessary padding.</p> 
    <div class="code" data-type="css">
    .ui.thingy {
      margin: 1em 0em;
    }
    .ui.thingy:first-child {
      margin-top: 0em;
    }
    .ui.thingy:last-child {
      margin-bottom: 0em;
    }
    </div>


    <h4 class="ui header">Grammatical order</h4>
    <p>Consider using similar class syntax as if you were actually describing the element in English. Although this is by no means required it may help provide clarity in some circumstances.</p>
    <div class="code" data-type="css">
    /* confusing word order */
    .ui.red.button.pointing {
      
    }
    /* much more semantic */
    .red.pointing.ui.button {
      
    }
    </div>

    <h4 class="ui header">Use Border Box</h4>
    <p>Border box fixes the box model, and allows padding to be included as part of width and height definitions. Using it opens up another world of possibilities for sizing content to fit fluidly</p>
    <div class="code" data-type="css">
    .two.ui.thingies .ui.thingy {
      width: 50%;
      padding: 1em;
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      -ms-box-sizing: border-box;
      box-sizing: border-box;
    }
    </div>

  <h2 class="ui dividing header">Units and Measurements</h2>

    <h4 class="ui header">Unit Consistency</h4>
    <p>CSS provides a broad selection of measurements for values. It is helpful to keep unit definitions consistent across a single property definition. Including consistent units for 0 values also allows for quicker tweaking and shows greater precision in a property definition.</p>
   
    <div class="code" data-type="css">
    /* not tops */
    .ui.widget {
      padding:  0 16px .6em;
    }
    /* hex are uppercase */
    .ui.widget {
      color: #09ffda;
    }
    /* good */
    .ui.widget {
      padding: 0em 0em 0em 0.2em;
      color: #009FDA;
    }
    </div>

    <h4 class="ui header"><em>Relatively</em> Relative</h4>
    <p>EMs are defined so that 1em is equal to the current font size inside of an element. Using EMs can allow you to size content inside an element in proportion to the overall size of the element. Be careful though because this will stack with nested elements.</p>
    <div class="code" data-type="css">
    .ui.thingy {
      font-size: 14px;
    }
    /* this is 28 pixels */
    .ui.thingy .thing {
      font-size: 2em;
    }
    /* woah this is now 48 pixels */
    .ui.thingy .thing .thing {
      font-size: 2em;
    }

    /* .ui.thingy .thingy should grow as well */
    .ui.large.thingy {
      font-size: 16px;
    }
    </div>

    <h4 class="ui header"><em>Recursively</em> Relative</h4>
    <p>Using EMs multiplicative nature can be used to your advantage. Instead of defining multiple tiers of a menu system, consider using ems to reduce each tier's sizing. As you continue to nest menu elements each nested menu will computer its values with smaller proportions.</p>
    <div class="code" data-type="css">
    .ui.menu {
      font-size: 1rem;
    }
    .ui.menu .menu {
      margin-left: 0.5em;
      font-size: 0.9em;
    }
    </div>
  
    <h4 class="ui header"><em>Absolutely</em> Relative</h4>
    <p>Relative EMs (rems) are calculated relative to the font size of the entire page. This is needed to explain how content should be sized related to the overall size of elements on the page, and will not increase geometrically when nested like EMs.</p>
    <div class="code" data-type="css">
    /* i am a weird page with very tiny fonts */
    html {
      font-size: 10px;
    }
    /* thats ok i am sizing everything relative to your tiny fonts */
    .ui.menu {
      font-size: 1rem;
    }
    /* i am sizing relative to the menu element */
    .ui.menu .menu {
      font-size: 0.8em;
    }
    /* i am the same size as the rule above */
    .ui.menu .menu .menu {
      font-size: 0.8em;
    }
    </div>


  <h2 class="ui dividing header">Techniques</h2>

    <h4 class="ui header">Prevent Accidental Highlighting</h4>
    <p>Sometimes text can be accidentally highlighted when a user double clicks an element. No need to pull out javascript to solve this.</p>
    <div class="code" data-type="css">
    .ui.thingy {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    </div>

    <h4 class="ui header">Joining borders</h4>
    <p>Sometimes bordered content must sit next to other bordered content. If each element uses border the borders will double. Consider using either outline or a box shadow to accomplish the same effect but without overlapping borders.</p>
    <div class="code" data-type="css">
    /* this might not go so well */
    .ui.thingy {
      border: 1px solid #DDDDDD;
    }
    /* rgba is great, but keep in mind the overlapping borders will be added together to create a darker shade */
    .ui.thingy {
      outline: 1px solid rgba(0, 0, 0, 0.1);
    }
    /* classic but works */
    .ui.thingy {
      outline: 1px solid #DDDDDD;
    }
    /* this works too */
    .ui.thingy {
      -moz-box-shadow: 0px 0px 0px 1px #DDDDDD;
      -webkit-box-shadow: 0px 0px 0px 1px #DDDDDD;
      box-shadow: 0px 0px 0px 1px #DDDDDD;
    }
    </div>

    <h4 class="ui header">Using transparency</h4>
    <p>RGBA colors in css allow you to specify colors with a transparency channel. This is very useful.</p>
    <p>Consider for example, defining the text states of an element. If the elements color changes, the text might appear more complementary as a shade of black with a portion of the original color. This can be done easily with rgba</p>
    <div class="code" data-type="css">
    .ui.thingy {
      background-color: #FAFAFA;
      color: rgba(0, 0, 0, 0.7);
    }
    .red.ui.thingy {
      background-color: #FF0000;
    }
    </div>

    <h4 class="ui header">Consider alternatives to floats</h4>
    <p>CSS floats can create issues with the containing element not receiving the size of its children. Using overflow:hidden to clear floats means that no peice of an element can be shown outside the bounding box of the element, which limits the possibilities in an element. Clearfixes can use up one of two available pseudo class which can often be useful for styling elements.</p>
    <p>Consider using another means of putting content side by side like inline-block or table-cell. These provide more freedom than floated block elements, and can add additional benefits.</p>
    <p>To avoid issues with inline-block causing spacing between elements, specify no font size on the group and 1rem on the floated content</p>
    <div class="code" data-type="css">
    /* not the best */
    .ui.thingy {
      display: block;
      overflow: hidden;
    }
    .ui.thingy .part {
      display: block;
      float: left;
    }

    /* these do the same thing */
    .ui.thingy {
      display: block;
      font-size: 0rem;
    }
    .ui.thingy .part {
      display: inline-block;
      font-size: 1rem;
    }
    </div>


    <h4 class="ui header">Onion Skinning</h4>
    <p>One technique that is useful for allowing for multiple color variations of an element, without having to completely reskin each variation and shade is to use background-image gradients to define shading and state, and background-color to define the color of an element. If done well you can add a variety of colors with very little code.</p>
    <div class="code" data-type="css">
    .ui.thingy {
      background-color: #FAFAFA;
    }
    .ui.red.thingy {
      background-color: #FF0000;
    }
    .ui.green.thingy {
      background-color: #00FF00;
    }
    .ui.blue.thingy {
      background-color: #0000FF;
    }
    .ui.thingy:hover {
      background-image: 
        -webkit-gradient(linear, 0 0, 0 100%, from(rgba(0, 0, 0, 0.1)), to(rgba(0, 0, 0, 0.05)))
      ;
      background-image: -webkit-linear-gradient(
        rgba(0, 0, 0, 0.1) 0%, 
        rgba(0, 0, 0, 0.05) 100%)
      ;
      background-image: -moz-linear-gradient(
        rgba(0, 0, 0, 0.1) 0%, 
        rgba(0, 0, 0, 0.05) 100%)
      ;
      background-image: -o-linear-gradient(
        rgba(0, 0, 0, 0.1) 0%, 
        rgba(0, 0, 0, 0.05) 100%)
      ;
      background-image: linear-gradient(
        rgba(0, 0, 0, 0.1) 0%, 
        rgba(0, 0, 0, 0.05) 100%)
      ;
    }
    </div>
  
</div>